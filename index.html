<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibePro 2.0 - é›²ç«¯ä»»å‹™å„€è¡¨æ¿</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background: #f8fafc; }
        .task-card { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .task-card:hover { transform: translateY(-4px); box-shadow: 0 20px 40px -15px rgba(0,0,0,0.08); }
        .modal-bg { background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(20px); }
        /* éš±è—æ²è»¸ä½†ä¿ç•™åŠŸèƒ½ */
        ::-webkit-scrollbar { width: 0px; background: transparent; }
    </style>
</head>
<body class="text-gray-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const PRIORITY_MAP = {
            high: { color: '#ef4444', label: 'ğŸ”´ ç·Šæ€¥', bg: 'bg-red-50', text: 'text-red-600' },
            medium: { color: '#fbbf24', label: 'ğŸŸ¡ æ™®é€š', bg: 'bg-amber-50', text: 'text-amber-600' },
            low: { color: '#10b981', label: 'ğŸŸ¢ ä½å„ªå…ˆ', bg: 'bg-emerald-50', text: 'text-emerald-600' },
            home: { color: '#a855f7', label: 'ğŸ  å®¶å‹™', bg: 'bg-purple-50', text: 'text-purple-600' }
        };

        function App() {
            // --- ç‹€æ…‹å®šç¾© ---
            const [tasks, setTasks] = useState(() => {
                const saved = localStorage.getItem('vibe-pro-final');
                return saved ? JSON.parse(saved) : [];
            });
            const [view, setView] = useState('active'); // 'active' æˆ– 'completed'
            const [selectedTask, setSelectedTask] = useState(null);
            const [form, setForm] = useState({ text: '', priority: 'medium', start: '', end: '' });
            const [showAddForm, setShowAddForm] = useState(false);
            const [tempText, setTempText] = useState('');
            const [activeInput, setActiveInput] = useState({ type: null, issueId: null });
            const [isLoaded, setIsLoaded] = useState(false);

            const CLOUD_URL = "https://script.google.com/macros/s/AKfycbwVZtUFKOj2Gqv2jMj43F02w88p1JK4D8hyz49YzMPbJbymhHdnZVPfbgQ6OP5_IFUR/exec";

            // --- é›²ç«¯é€£å‹•é‚è¼¯ ---
            useEffect(() => {
                const loadFromCloud = async () => {
                    try {
                        const response = await fetch(CLOUD_URL);
                        const cloudData = await response.json();
                        if (Array.isArray(cloudData) && cloudData.length > 0) {
                            setTasks(cloudData);
                        }
                    } catch (error) {
                        console.error("è®€å–å¤±æ•—:", error);
                    } finally {
                        setIsLoaded(true);
                    }
                };
                loadFromCloud();
            }, []);

            const syncToCloud = async (currentTasks) => {
                try {
                    await fetch(CLOUD_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ tasks: currentTasks })
                    });
                } catch (error) { console.error("å‚™ä»½å¤±æ•—:", error); }
            };

            useEffect(() => {
                if (isLoaded && tasks.length >= 0) {
                    localStorage.setItem('vibe-pro-final', JSON.stringify(tasks));
                    syncToCloud(tasks);
                }
            }, [tasks, isLoaded]);

            // --- åŠŸèƒ½å‡½æ•¸ ---
            const handleAdd = () => {
                if (!form.text.trim()) return;
                const newTask = { id: Date.now(), ...form, progress: 0, description: '', issues: [], isDone: false };
                setTasks([newTask, ...tasks]);
                setForm({ text: '', priority: 'medium', start: '', end: '' });
                setShowAddForm(false);
            };

            const performDelete = (id) => {
                if (window.confirm("âš ï¸ ç¢ºå®šè¦åˆªé™¤å—ï¼Ÿæ­¤å‹•ä½œç„¡æ³•å¾©åŸã€‚")) {
                    setTasks(prev => prev.filter(t => t.id !== id));
                    setSelectedTask(null);
                }
            };

            const updateTask = (id, field, value) => {
                setTasks(prev => prev.map(t => t.id === id ? { ...t, [field]: value } : t));
                if (selectedTask?.id === id) {
                    setSelectedTask(prev => ({ ...prev, [field]: value }));
                }
            };

            const toggleTaskDone = (id) => {
                setTasks(prev => prev.map(t => t.id === id ? { ...t, isDone: !t.isDone, progress: !t.isDone ? 100 : t.progress } : t));
                setSelectedTask(null);
            };

            const submitIssue = (taskId) => {
                if (!tempText.trim()) return;
                const task = tasks.find(t => t.id === taskId);
                updateTask(taskId, 'issues', [...(task.issues || []), { id: Date.now(), q: tempText, a: '', done: false }]);
                setTempText('');
                setActiveInput({ type: null, issueId: null });
            };

            const submitSolution = (taskId, issueId) => {
                if (!tempText.trim()) return;
                const task = tasks.find(t => t.id === taskId);
                const newIssues = task.issues.map(is => is.id === issueId ? { ...is, a: tempText, done: true } : is);
                updateTask(taskId, 'issues', newIssues);
                setTempText('');
                setActiveInput({ type: null, issueId: null });
            };

            const filteredTasks = tasks.filter(t => view === 'active' ? !t.isDone : t.isDone);

            return (
                <div className="min-h-screen flex">
                    {/* å·¦å´å°è¦½åˆ— */}
                    <aside className="w-20 md:w-64 border-r border-gray-100 bg-white p-4 md:p-8 flex flex-col sticky top-0 h-screen">
                        <div className="flex items-center gap-3 mb-12">
                            <div className="w-10 h-10 bg-black rounded-2xl flex items-center justify-center text-white font-black text-xl shadow-2xl rotate-3">V</div>
                            <h1 className="text-xl font-black tracking-tighter hidden md:block italic">VIBEPRO 2.0</h1>
                        </div>
                        <nav className="flex-1 space-y-3">
                            <button onClick={() => setView('active')} className={`w-full flex items-center gap-4 px-4 py-4 rounded-[1.5rem] font-bold transition-all ${view === 'active' ? 'bg-black text-white shadow-xl scale-10